<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Metakit: c4_View Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.3 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>c4_View Class Reference</h1><!-- doxytag: class=<c4_View> -->A collection of data rows.  
<a href="#_details">More...</a>
<p>
Inheritance diagram for c4_View:<p><center><img src="classc4___view__inherit__graph.png" border="0" usemap="#c4___view__inherit__map" alt="Inheritance graph"></center>
<map name="c4___view__inherit__map">
<area href="classc4___storage.html" shape="rect" coords="8,83,96,107" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classc4___view-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0"></a><!-- doxytag: member=<c4_View::c4_View> ref=<a0> args=<(c4_Sequence *=0)> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a0">c4_View</a> (<a class="el" href="classc4___sequence.html">c4_Sequence</a> *=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a view based on a sequence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1"></a><!-- doxytag: member=<c4_View::c4_View> ref=<a1> args=<(c4_CustomViewer *)> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a1">c4_View</a> (<a class="el" href="classc4___custom_viewer.html">c4_CustomViewer</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a view based on a custom viewer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2"></a><!-- doxytag: member=<c4_View::c4_View> ref=<a2> args=<(c4_Stream *)> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a2">c4_View</a> (<a class="el" href="classc4___stream.html">c4_Stream</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a view based on an input stream. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3"></a><!-- doxytag: member=<c4_View::c4_View> ref=<a3> args=<(const c4_Property &amp;property_)> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a3">c4_View</a> (const <a class="el" href="classc4___property.html">c4_Property</a> &amp;property_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty view with one property. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4"></a><!-- doxytag: member=<c4_View::c4_View> ref=<a4> args=<(const c4_View &amp;)> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a4">c4_View</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5"></a><!-- doxytag: member=<c4_View::~c4_View> ref=<a5> args=<()> -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a5">~c4_View</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor, decrements reference count. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6"></a><!-- doxytag: member=<c4_View::operator=> ref=<a6> args=<(const c4_View &amp;)> -->
<a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a6">operator=</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes this view the same as another one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7"></a><!-- doxytag: member=<c4_View::Persist> ref=<a7> args=<() const > -->
c4_Persist *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a7">Persist</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the persistence handler, or zero. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8"></a><!-- doxytag: member=<c4_View::GetSize> ref=<a8> args=<() const > -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a8">GetSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of entries in this view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a9">SetSize</a> (int, int=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the size of this view Since views act like dynamic arrays, you can quickly change their size.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10"></a><!-- doxytag: member=<c4_View::RemoveAll> ref=<a10> args=<()> -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a10">RemoveAll</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all entries (sets size to zero). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11"></a><!-- doxytag: member=<c4_View::GetAt> ref=<a11> args=<(int) const > -->
<a class="el" href="classc4___row_ref.html">c4_RowRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a11">GetAt</a> (int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to specified entry, for use as RHS or LHS. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___row_ref.html">c4_RowRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a12">operator[]</a> (int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Element access, shorthand for GetAt.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a13">SetAt</a> (int, const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the value of the specified entry.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___row_ref.html">c4_RowRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a14">ElementAt</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Element access, shorthand for GetAt.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a15">GetItem</a> (int, int, <a class="el" href="classc4___bytes.html">c4_Bytes</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a single data item in a generic way.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16"></a><!-- doxytag: member=<c4_View::SetItem> ref=<a16> args=<(int, int, const c4_Bytes &amp;) const > -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a16">SetItem</a> (int, int, const <a class="el" href="classc4___bytes.html">c4_Bytes</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a single data item in a generic way. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17"></a><!-- doxytag: member=<c4_View::SetAtGrow> ref=<a17> args=<(int, const c4_RowRef &amp;)> -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a17">SetAtGrow</a> (int, const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an entry, growing the view if needed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a18">Add</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new entry, same as "SetAtGrow(<a class="el" href="classc4___view.html#a8">GetSize()</a>, .  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a19">InsertAt</a> (int, const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;, int=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a copy of the contents of another view.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a20">RemoveAt</a> (int, int=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove entries starting at the given index.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a21"></a><!-- doxytag: member=<c4_View::InsertAt> ref=<a21> args=<(int, const c4_View &amp;)> -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a21">InsertAt</a> (int, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert copies of all rows of the specified view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a23">RelocateRows</a> (int, int, <a class="el" href="classc4___view.html">c4_View</a> &amp;, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move attached rows to somewhere else in same storage.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a24">NumProperties</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of properties present in this view.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classc4___property.html">c4_Property</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a25">NthProperty</a> (int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the N-th property (using zero-based indexing).  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a26">FindProperty</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of a property, given its id.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a27">FindPropIndexByName</a> (const char *) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of a property, given its name.  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a28">Duplicate</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new view with a copy of the data.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a29">Clone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new view with the same structure but no data.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a30">AddProperty</a> (const <a class="el" href="classc4___property.html">c4_Property</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a property column to a view if not already present.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a31">operator,</a> (const <a class="el" href="classc4___property.html">c4_Property</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a column for a property.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32"></a><!-- doxytag: member=<c4_View::Description> ref=<a32> args=<() const > -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a32">Description</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a decription if there is a fixed structure, else zero. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a33">Sort</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with all rows in natural (property-wise) order.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a34">SortOn</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view sorted according to the specified properties.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a35">SortOnReverse</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create sorted view, with some properties sorted in reverse.  <a href="#a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a36">Select</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with rows matching the specified value.  <a href="#a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a37">SelectRange</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;, const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with row values within the specified range.  <a href="#a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a38">Project</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with the specified property arrangement.  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a39">ProjectWithout</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create derived view with some properties omitted.  <a href="#a39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a40">GetIndexOf</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of the specified row in this view (or -1).  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a41"></a><!-- doxytag: member=<c4_View::RestrictSearch> ref=<a41> args=<(const c4_RowRef &amp;, int &amp;, int &amp;)> -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a41">RestrictSearch</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;, int &amp;, int &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the search range for rows. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a42">Slice</a> (int, int=-1, int=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which is a segment/slice (default is up to end).  <a href="#a42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a43">Product</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which is the cartesian product with given view.  <a href="#a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a44">RemapWith</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which remaps another given view.  <a href="#a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a45">Pair</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which pairs each row with corresponding row.  <a href="#a45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a46">Concat</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with rows from another view appended.  <a href="#a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a47">Rename</a> (const <a class="el" href="classc4___property.html">c4_Property</a> &amp;, const <a class="el" href="classc4___property.html">c4_Property</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with one property renamed (must be of same type).  <a href="#a47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a48">GroupBy</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view_prop.html">c4_ViewProp</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with a subview, grouped by the specified properties.  <a href="#a48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a49">Counts</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___int_prop.html">c4_IntProp</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with count of duplicates, when grouped by key.  <a href="#a49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a50">Unique</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with all duplicate rows omitted.  <a href="#a50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a51">Union</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which is the set union (assumes no duplicate rows).  <a href="#a51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a52">Intersect</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with all rows also in the given view (no dups).  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a53">Different</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with all rows not in both views (no dups).  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a54">Minus</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with all rows not in the given view (no dups).  <a href="#a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a55">JoinProp</a> (const <a class="el" href="classc4___view_prop.html">c4_ViewProp</a> &amp;, bool=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view with a specific subview expanded, like a join.  <a href="#a55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a56">Join</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;, bool=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create view which is the relational join on the given keys.  <a href="#a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a57">ReadOnly</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an identity view which only allows reading.  <a href="#a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a58">Hash</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, int=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create mapped view which adds a hash lookup layer.  <a href="#a58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a59">Blocked</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create mapped view which blocks its rows in two levels.  <a href="#a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a60">Ordered</a> (int=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create mapped view which keeps its rows ordered.  <a href="#a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classc4___view.html">c4_View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a61">Indexed</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;, bool=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create mapped view which maintains an index permutation.  <a href="#a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a62">Find</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;, int=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find index of the the next entry matching the specified key.  <a href="#a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a63">Search</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a key, using the native sort order of the view.  <a href="#a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a64"></a><!-- doxytag: member=<c4_View::Locate> ref=<a64> args=<(const c4_RowRef &amp;, int *=0) const > -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a64">Locate</a> (const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;, int *=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of matching keys, and pos of first one as arg. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a65"></a><!-- doxytag: member=<c4_View::Compare> ref=<a65> args=<(const c4_View &amp;) const > -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#a65">Compare</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two views lexicographically (rows 0..N-1). <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0"></a><!-- doxytag: member=<c4_View::_IncSeqRef> ref=<b0> args=<()> -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#b0">_IncSeqRef</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase the reference count of the associated sequence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1"></a><!-- doxytag: member=<c4_View::_DecSeqRef> ref=<b1> args=<()> -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#b1">_DecSeqRef</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease the reference count of the associated sequence. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n0"></a><!-- doxytag: member=<c4_View::c4_ViewRef> ref=<n0> args=<> -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n0">c4_ViewRef</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">View references are allowed to peek inside view objects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n1"></a><!-- doxytag: member=<c4_View::operator==> ref=<n1> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n1">operator==</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the contents of both views are equal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n2"></a><!-- doxytag: member=<c4_View::operator!=> ref=<n2> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n2">operator!=</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the contents of both views are not equal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n3"></a><!-- doxytag: member=<c4_View::operator<> ref=<n3> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n3">operator&lt;</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if first view is less than second view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n4"></a><!-- doxytag: member=<c4_View::operator>> ref=<n4> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n4">operator&gt;</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if first view is greater than second view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n5"></a><!-- doxytag: member=<c4_View::operator<=> ref=<n5> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n5">operator&lt;=</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if first view is less or equal to second view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n6"></a><!-- doxytag: member=<c4_View::operator>=> ref=<n6> args=<(const c4_View &amp;, const c4_View &amp;)> -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc4___view.html#n6">operator&gt;=</a> (const <a class="el" href="classc4___view.html">c4_View</a> &amp;, const <a class="el" href="classc4___view.html">c4_View</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if first view is greater or equal to second view. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A collection of data rows. 
<p>
This is the central public data structure of Metakit (often called "table", "array", or "relation" in other systems).<p>
Views are smart pointers to the actual collections, setting a view to a new value does not alter the collection to which this view pointed previously.<p>
The elements of views can be referred to by their 0-based index, which produces a row-reference of type <a class="el" href="classc4___row_ref.html">c4_RowRef</a>. These row references can be copied, used to get or set properties, or dereferenced (in which case an object of class <a class="el" href="classc4___row.html">c4_Row</a> is returned). Taking the address of a row reference produces a <a class="el" href="classc4___cursor.html">c4_Cursor</a>, which acts very much like a pointer.<p>
The following code creates a view with 1 row and 2 properties: <div class="fragment"><pre class="fragment">    <a class="code" href="classc4___string_prop.html">c4_StringProp</a> pName (<span class="stringliteral">"name"</span>);
    <a class="code" href="classc4___int_prop.html">c4_IntProp</a> pAge (<span class="stringliteral">"age"</span>);

    <a class="code" href="classc4___row.html">c4_Row</a> data;
    pName (data) = <span class="stringliteral">"John Williams"</span>;
    pAge (data) = 43;

    <a class="code" href="classc4___view.html">c4_View</a> myView;
    myView.<a class="code" href="classc4___view.html#a18">Add</a>(row);
</pre></div>
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a18"></a><!-- doxytag: member=<c4_View::Add> ref=<a18> args=<(const c4_RowRef &amp;)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::Add           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>newElem_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a new entry, same as "SetAtGrow(<a class="el" href="classc4___view.html#a8">GetSize()</a>, . 
<p>
..)" <dl compact><dt><b>Returns:</b></dt><dd>the index of the newly added row</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30"></a><!-- doxytag: member=<c4_View::AddProperty> ref=<a30> args=<(const c4_Property &amp;)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::AddProperty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___property.html">c4_Property</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>prop_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Adds a property column to a view if not already present. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0-based column position of the property</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a59"></a><!-- doxytag: member=<c4_View::Blocked> ref=<a59> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Blocked           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create mapped view which blocks its rows in two levels. 
<p>
This view acts like a large flat view, even though the actual rows are stored in blocks, which are rebalanced automatically to maintain a good trade-off between block size and number of blocks.<p>
The underlying view must be defined with a single view property, with the structure of the subview being as needed. An example of a blocked view definition which will act like a single one containing 2 properties: <div class="fragment"><pre class="fragment">  <a class="code" href="classc4___view.html">c4_View</a> raw = storage.GetAs(<span class="stringliteral">"people[_B[name:S,age:I]]"</span>);
  <a class="code" href="classc4___view.html">c4_View</a> flat = raw.<a class="code" href="classc4___view.html#a59">Blocked</a>();
  ... flat.<a class="code" href="classc4___view.html#a8">GetSize</a>() ...
  flat.<a class="code" href="classc4___view.html#a19">InsertAt</a>(...)
</pre></div><p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a29"></a><!-- doxytag: member=<c4_View::Clone> ref=<a29> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Clone           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a new view with the same structure but no data. 
<p>
Structural information can only be maintain for the top level, subviews will be included but without any properties themselves.    </td>
  </tr>
</table>
<a class="anchor" name="a46"></a><!-- doxytag: member=<c4_View::Concat> ref=<a46> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Concat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with rows from another view appended. 
<p>
Constructs a view which has all rows of this view, and all rows of the second view appended. The structure of the second view is assumed to be identical to this one. This operation is a bit similar to appending all rows from the second view, but it does not actually store the result anywhere, it just looks like it.<p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a49"></a><!-- doxytag: member=<c4_View::Counts> ref=<a49> args=<(const c4_View &amp;, const c4_IntProp &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Counts           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>keys_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___int_prop.html">c4_IntProp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with count of duplicates, when grouped by key. 
<p>
This is similar to <a class="el" href="classc4___view.html#a48">c4_View::GroupBy</a>, but it determines only the number of rows in each group and does not create a nested view.<p>
This view operation is based on a read-only custom viewer.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>keys_</em>&nbsp;</td><td>
properties in this view determine grouping </td></tr>
<tr><td valign="top"><em>result_</em>&nbsp;</td><td>
new count property defined in result </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a53"></a><!-- doxytag: member=<c4_View::Different> ref=<a53> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Different           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with all rows not in both views (no dups). 
<p>
Calculates the "XOR" of two sets. This will only work if both input views are sets, i.e. they have no duplicate rows in them.<p>
This view operation is based on a read-only custom viewer.    </td>
  </tr>
</table>
<a class="anchor" name="a28"></a><!-- doxytag: member=<c4_View::Duplicate> ref=<a28> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Duplicate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a new view with a copy of the data. 
<p>
The copy is a deep copy, because subviews are always copied in full.    </td>
  </tr>
</table>
<a class="anchor" name="a14"></a><!-- doxytag: member=<c4_View::ElementAt> ref=<a14> args=<(int)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___row_ref.html">c4_RowRef</a> c4_View::ElementAt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Element access, shorthand for GetAt. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the specified row in the view. This reference can be used on either side of the assignment operator.</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>index_</em>&nbsp;</td><td>
zero-based row index </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a62"></a><!-- doxytag: member=<c4_View::Find> ref=<a62> args=<(const c4_RowRef &amp;, int=0) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::Find           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>crit_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>start_</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find index of the the next entry matching the specified key. 
<p>
Defaults to linear search, but hash- and ordered-views will use a better algorithm if possible. Only the properties present in the search key are used to determine whether a row matches the key. <dl compact><dt><b>Returns:</b></dt><dd>position where match occurred </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>if not found</td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>crit_</em>&nbsp;</td><td>
the value to look for </td></tr>
<tr><td valign="top"><em>start_</em>&nbsp;</td><td>
the index to start with </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a26"></a><!-- doxytag: member=<c4_View::FindProperty> ref=<a26> args=<(int)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::FindProperty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>propId_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the index of a property, given its id. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>propId_</em>&nbsp;</td><td>Unique id associated to a specific propoerty </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The index of the property, or -1 of it was not found</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27"></a><!-- doxytag: member=<c4_View::FindPropIndexByName> ref=<a27> args=<(const char *) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::FindPropIndexByName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the index of a property, given its name. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0-based column index </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>property not present in this view</td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>name_</em>&nbsp;</td><td>
property name (case insensitive) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a40"></a><!-- doxytag: member=<c4_View::GetIndexOf> ref=<a40> args=<(const c4_RowRef &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::GetIndexOf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>row_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the index of the specified row in this view (or -1). 
<p>
This function can be used to "unmap" an index of a derived view back to the original underlying view.    </td>
  </tr>
</table>
<a class="anchor" name="a15"></a><!-- doxytag: member=<c4_View::GetItem> ref=<a15> args=<(int, int, c4_Bytes &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool c4_View::GetItem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>row_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>col_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classc4___bytes.html">c4_Bytes</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buf_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a single data item in a generic way. 
<p>
This can be used to access view data in a generalized way. Useful for c4_CustomViewers which are based on other views. <dl compact><dt><b>Returns:</b></dt><dd>true if the item is non-empty</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48"></a><!-- doxytag: member=<c4_View::GroupBy> ref=<a48> args=<(const c4_View &amp;, const c4_ViewProp &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::GroupBy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>keys_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___view_prop.html">c4_ViewProp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with a subview, grouped by the specified properties. 
<p>
This operation is similar to the SQL 'GROUP BY', but it takes advantage of the fact that Metakit supports nested views. The view returned from this member has one row per distinct group, with an extra view property holding the remaining properties. If there are N rows in the original view matching key X, then the result is a row for key X, with a subview of N rows. The properties of the subview are all the properties not in the key.<p>
This view operation is based on a read-only custom viewer.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>keys_</em>&nbsp;</td><td>
properties in this view determine grouping </td></tr>
<tr><td valign="top"><em>result_</em>&nbsp;</td><td>
name of new subview defined in result </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a58"></a><!-- doxytag: member=<c4_View::Hash> ref=<a58> args=<(const c4_View &amp;, int=1) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Hash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>map_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>numKeys_</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create mapped view which adds a hash lookup layer. 
<p>
This view creates and manages a special hash map view, to implement a fast find on the key. The key is defined to consist of the first numKeys_ properties of the underlying view.<p>
The map_ view must be empty the first time this hash view is used, so that Metakit can fill it based on whatever rows are already present in the underlying view. After that, neither the underlying view nor the map view may be modified other than through this hash mapping layer. The defined structure of the map view must be "_H:I,_R:I".<p>
This view is modifiable. Insertions and changes to key field properties can cause rows to be repositioned to maintain hash uniqueness. Careful: when a row is changed in such a way that its key is the same as in another row, that other row will be deleted from the view.<p>
Example of use: <div class="fragment"><pre class="fragment">  <a class="code" href="classc4___view.html">c4_View</a> data = storage.GetAs(<span class="stringliteral">"people[name:S,age:I]"</span>);
  <a class="code" href="classc4___view.html">c4_View</a> datah = storage.GetAs(<span class="stringliteral">"people_H[_H:I,_R:I]"</span>);
  <a class="code" href="classc4___view.html">c4_View</a> hash = raw.<a class="code" href="classc4___view.html#a58">Hash</a>(datah, 1);
  ... hash.<a class="code" href="classc4___view.html#a8">GetSize</a>() ...
  hash.<a class="code" href="classc4___view.html#a18">Add</a>(...)
</pre></div>    </td>
  </tr>
</table>
<a class="anchor" name="a61"></a><!-- doxytag: member=<c4_View::Indexed> ref=<a61> args=<(const c4_View &amp;, const c4_View &amp;, bool=false) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Indexed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>map_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>props_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>unique_</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create mapped view which maintains an index permutation. 
<p>
This is an identity view which somewhat resembles the ordered view, it maintains a secondary "map" view to contain the permutation to act as an index. The indexed view presents the same order of rows as the underlying view, but the index map is set up in such a way that binary search is possible on the keys specified. When the "unique" parameter is true, insertions which would create a duplicate key are ignored.<p>
This view is modifiable. Careful: when a row is changed in such a way that its key is the same as in another row, that other row will be deleted from the view.    </td>
  </tr>
</table>
<a class="anchor" name="a19"></a><!-- doxytag: member=<c4_View::InsertAt> ref=<a19> args=<(int, const c4_RowRef &amp;, int=1)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void c4_View::InsertAt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>index_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>newElem_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count_</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a copy of the contents of another view. 
<p>
This is identical to inserting the specified number of default entries and then setting each of them to the new element value passed as argument.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>index_</em>&nbsp;</td><td>
zero-based row index </td></tr>
<tr><td valign="top"><em>newElem_</em>&nbsp;</td><td>
the value to insert </td></tr>
<tr><td valign="top"><em>count_</em>&nbsp;</td><td>
number of copies to insert, must be &gt; 0 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a52"></a><!-- doxytag: member=<c4_View::Intersect> ref=<a52> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Intersect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with all rows also in the given view (no dups). 
<p>
Calculates the set intersection. This will only work if both input views are sets, i.e. they have no duplicate rows in them.<p>
This view operation is based on a read-only custom viewer.    </td>
  </tr>
</table>
<a class="anchor" name="a56"></a><!-- doxytag: member=<c4_View::Join> ref=<a56> args=<(const c4_View &amp;, const c4_View &amp;, bool=false) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Join           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>keys_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>view_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>outer_</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which is the relational join on the given keys. 
<p>
This view operation is based on a read-only custom viewer.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>keys_</em>&nbsp;</td><td>
properties in this view determine the join </td></tr>
<tr><td valign="top"><em>view_</em>&nbsp;</td><td>
second view participating in the join </td></tr>
<tr><td valign="top"><em>outer_</em>&nbsp;</td><td>
true: keep rows with no match in second view </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a55"></a><!-- doxytag: member=<c4_View::JoinProp> ref=<a55> args=<(const c4_ViewProp &amp;, bool=false) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::JoinProp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view_prop.html">c4_ViewProp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sub_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>outer_</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with a specific subview expanded, like a join. 
<p>
This operation is the inverse of <a class="el" href="classc4___view.html#a48">c4_View::GroupBy</a>, expanding all rows in specified subview and returning a view which looks as if the rows in each subview were "expanded in place".<p>
This view operation is based on a read-only custom viewer.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>sub_</em>&nbsp;</td><td>
name of the subview to expand </td></tr>
<tr><td valign="top"><em>outer_</em>&nbsp;</td><td>
true: keep rows with empty subviews </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a54"></a><!-- doxytag: member=<c4_View::Minus> ref=<a54> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Minus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with all rows not in the given view (no dups). 
<p>
Calculates set-difference of this view minus arg view. Result is a subset, unlike <a class="el" href="classc4___view.html#a53">c4_View::Different</a>. Will only work if both input views are sets, i.e. they have no duplicate rows in them.<p>
This view operation is based on a read-only custom viewer.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>view_</em>&nbsp;</td><td>
the second view </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a25"></a><!-- doxytag: member=<c4_View::NthProperty> ref=<a25> args=<(int) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___property.html">c4_Property</a> &amp; c4_View::NthProperty           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the N-th property (using zero-based indexing). 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>reference to the specified property</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>index_</em>&nbsp;</td><td>
the zero-based property index </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a24"></a><!-- doxytag: member=<c4_View::NumProperties> ref=<a24> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::NumProperties           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of properties present in this view. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A non-negative integer</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31"></a><!-- doxytag: member=<c4_View::operator,> ref=<a31> args=<(const c4_Property &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::operator,           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___property.html">c4_Property</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>prop_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Defines a column for a property. 
<p>
The following code defines an empty view with three properties: <div class="fragment"><pre class="fragment">  <a class="code" href="classc4___int_prop.html">c4_IntProp</a> p1, p2, p3;
  <a class="code" href="classc4___view.html">c4_View</a> myView = (p1, p2, p3);
</pre></div> <dl compact><dt><b>Returns:</b></dt><dd>the new view object (without any data rows) </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classc4___property.html">c4_Property</a></dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12"></a><!-- doxytag: member=<c4_View::operator[]> ref=<a12> args=<(int) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___row_ref.html">c4_RowRef</a> c4_View::operator[]           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Element access, shorthand for GetAt. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the specified row in the view. This reference can be used on either side of the assignment operator.</dd></dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>index_</em>&nbsp;</td><td>
zero-based row index </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a60"></a><!-- doxytag: member=<c4_View::Ordered> ref=<a60> args=<(int=1) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Ordered           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>numKeys_</em> = <code>1</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create mapped view which keeps its rows ordered. 
<p>
This is an identity view, which has as only use to inform Metakit that the underlying view can be considered to be sorted on its first numKeys_ properties. The effect is that <a class="el" href="classc4___view.html#a62">c4_View::Find</a> will try to use binary search when the search includes key properties (results will be identical to unordered views, the find will just be more efficient).<p>
This view is modifiable. Insertions and changes to key field properties can cause rows to be repositioned to maintain the sort order. Careful: when a row is changed in such a way that its key is the same as in another row, that other row will be deleted from the view.<p>
This view can be combined with <a class="el" href="classc4___view.html#a59">c4_View::Blocked</a>, to create a 2-level btree structure.    </td>
  </tr>
</table>
<a class="anchor" name="a45"></a><!-- doxytag: member=<c4_View::Pair> ref=<a45> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Pair           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which pairs each row with corresponding row. 
<p>
This is like a row-by-row concatenation. Both views must have the same number of rows, the result has all properties from this view plus any other properties from the other view.<p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a43"></a><!-- doxytag: member=<c4_View::Product> ref=<a43> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Product           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which is the cartesian product with given view. 
<p>
The cartesian product is defined as every combination of rows in both views. The number of entries is the product of the number of entries in the two views, properties which are present in both views will use the values defined in this view.<p>
This view operation is based on a read-only custom viewer.    </td>
  </tr>
</table>
<a class="anchor" name="a38"></a><!-- doxytag: member=<c4_View::Project> ref=<a38> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Project           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>in_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with the specified property arrangement. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but this only works when based on views which properly generate change notifications (.e. raw views, selections, and other projections).    </td>
  </tr>
</table>
<a class="anchor" name="a39"></a><!-- doxytag: member=<c4_View::ProjectWithout> ref=<a39> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::ProjectWithout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create derived view with some properties omitted. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but this only works when based on views which properly generate change notifications (.e. raw views, selections, and other projections).    </td>
  </tr>
</table>
<a class="anchor" name="a57"></a><!-- doxytag: member=<c4_View::ReadOnly> ref=<a57> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::ReadOnly           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an identity view which only allows reading. 
<p>
This view operation is based on a custom viewer.    </td>
  </tr>
</table>
<a class="anchor" name="a23"></a><!-- doxytag: member=<c4_View::RelocateRows> ref=<a23> args=<(int, int, c4_View &amp;, int)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void c4_View::RelocateRows           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>from_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dest_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pos_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move attached rows to somewhere else in same storage. 
<p>
There is a lot of trickery going on here. The whole point of this code is that moving rows between (compatible!) subviews should not use copying when potentially large memo's and subviews are involved. In that case, the best solution is really to move pointers, not data.    </td>
  </tr>
</table>
<a class="anchor" name="a44"></a><!-- doxytag: member=<c4_View::RemapWith> ref=<a44> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::RemapWith           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which remaps another given view. 
<p>
Remapping constructs a view with the rows indicated by another view. The first property in the order_ view must be an int property with index values referring to this one. The size of the resulting view is determined by the order_ view and can differ, for example to act as a subset selection (if smaller).<p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a20"></a><!-- doxytag: member=<c4_View::RemoveAt> ref=<a20> args=<(int, int=1)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void c4_View::RemoveAt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>index_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count_</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove entries starting at the given index. 
<p>
Entries which have other view references may cause these views to be deleted if their reference counts drop to zero because of this removal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index_</em>&nbsp;</td><td>the zero-based row index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count_</em>&nbsp;</td><td>the number of entries to remove</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a47"></a><!-- doxytag: member=<c4_View::Rename> ref=<a47> args=<(const c4_Property &amp;, const c4_Property &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Rename           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___property.html">c4_Property</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>old_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___property.html">c4_Property</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>new_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with one property renamed (must be of same type). 
<p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a63"></a><!-- doxytag: member=<c4_View::Search> ref=<a63> args=<(const c4_RowRef &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int c4_View::Search           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>crit_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Search for a key, using the native sort order of the view. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>position where found, or where it may be inserted, this position can also be just past the last row</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36"></a><!-- doxytag: member=<c4_View::Select> ref=<a36> args=<(const c4_RowRef &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Select           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>crit_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with rows matching the specified value. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but this only works when based on views which properly generate change notifications (.e. raw views, other selections, and projections).    </td>
  </tr>
</table>
<a class="anchor" name="a37"></a><!-- doxytag: member=<c4_View::SelectRange> ref=<a37> args=<(const c4_RowRef &amp;, const c4_RowRef &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::SelectRange           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>low_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>high_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with row values within the specified range. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but this only works when based on views which properly generate change notifications (.e. raw views, other selections, and projections).<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>low_</em>&nbsp;</td><td>
values of the lower bounds (inclusive) </td></tr>
<tr><td valign="top"><em>high_</em>&nbsp;</td><td>
values of the upper bounds (inclusive) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a13"></a><!-- doxytag: member=<c4_View::SetAt> ref=<a13> args=<(int, const c4_RowRef &amp;)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void c4_View::SetAt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>index_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___row_ref.html">c4_RowRef</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>newElem_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the value of the specified entry. 
<p>
If the new value has other properties, these will be added to the underlying view.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index_</em>&nbsp;</td><td>the zero-based row index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newElem_</em>&nbsp;</td><td>the row to copy to this view</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9"></a><!-- doxytag: member=<c4_View::SetSize> ref=<a9> args=<(int, int=-1)> --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void c4_View::SetSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>newSize_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>growBy_</em> = <code>-1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the size of this view Since views act like dynamic arrays, you can quickly change their size. 
<p>
Increasing the size will append rows with zero/empty values, while decreasing it will delete the last rows. The growBy_ parameter is currently unused.    </td>
  </tr>
</table>
<a class="anchor" name="a42"></a><!-- doxytag: member=<c4_View::Slice> ref=<a42> args=<(int, int=-1, int=1) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Slice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>first_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>limit_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>step_</em> = <code>1</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which is a segment/slice (default is up to end). 
<p>
Returns a view which is a subset, either a contiguous range, or a "slice" with element taken from every step_ entries. If the step is negative, the same entries are returned, but in reverse order (start_ is still lower index, it'll then be returned last).<p>
This view operation is based on a custom viewer and is modifiable.    </td>
  </tr>
</table>
<a class="anchor" name="a33"></a><!-- doxytag: member=<c4_View::Sort> ref=<a33> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Sort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with all rows in natural (property-wise) order. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but unfortunately there are some major limitations with this scheme - one of them being that deriving another view from this sorted one will not properly track changes.    </td>
  </tr>
</table>
<a class="anchor" name="a34"></a><!-- doxytag: member=<c4_View::SortOn> ref=<a34> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::SortOn           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>up_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view sorted according to the specified properties. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but unfortunately there are some major limitations with this scheme - one of them being that deriving another view from this sorted one will not properly track changes.    </td>
  </tr>
</table>
<a class="anchor" name="a35"></a><!-- doxytag: member=<c4_View::SortOnReverse> ref=<a35> args=<(const c4_View &amp;, const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::SortOnReverse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>up_</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>down_</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create sorted view, with some properties sorted in reverse. 
<p>
The result is virtual, it merely maintains a permutation to access the underlying view. This "derived" view uses change notification to track changes to the underlying view, but unfortunately there are some major limitations with this scheme - one of them being that deriving another view from this sorted one will not properly track changes.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>up_</em>&nbsp;</td><td>
the view which defines the sort order </td></tr>
<tr><td valign="top"><em>down_</em>&nbsp;</td><td>
subset of up_, defines reverse order </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a class="anchor" name="a51"></a><!-- doxytag: member=<c4_View::Union> ref=<a51> args=<(const c4_View &amp;) const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Union           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classc4___view.html">c4_View</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>view_</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view which is the set union (assumes no duplicate rows). 
<p>
Calculates the set union. This will only work if both input views are sets, i.e. they have no duplicate rows in them.<p>
This view operation is based on a read-only custom viewer.    </td>
  </tr>
</table>
<a class="anchor" name="a50"></a><!-- doxytag: member=<c4_View::Unique> ref=<a50> args=<() const > --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classc4___view.html">c4_View</a> c4_View::Unique           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create view with all duplicate rows omitted. 
<p>
This view operation is based on a read-only custom viewer.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mk4_8h-source.html">mk4.h</a><li><a class="el" href="mk4_8inl.html">mk4.inl</a><li><a class="el" href="view_8cpp.html">view.cpp</a></ul>
<br><hr size=1>
<center>
    Metakit C++ API Reference -
    <a href="http://www.equi4.com/metakit.html">http://www.equi4.com/metakit.html</a>
    - extracted with
    <a href="http://www.doxygen.org">Doxygen</a>
</center>
</body></html>
